#!/usr/bin/env python3
"""
FINAL_FIX.py - Ultimate Fix Script for AI Agent Service Toolkit
This script provides a complete solution for all setup and runtime issues.
"""

import os
import sys
import subprocess
import json
import socket
import shutil
import time
from pathlib import Path
from typing import Dict, List, Tuple, Optional

class Colors:
    """ANSI color codes for terminal output."""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

def print_header(text: str):
    """Print a colored header."""
    print(f"\n{Colors.BOLD}{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.CYAN}{text.center(60)}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.CYAN}{'='*60}{Colors.END}")

def print_success(text: str):
    """Print success message."""
    print(f"{Colors.GREEN}✅ {text}{Colors.END}")

def print_error(text: str):
    """Print error message."""
    print(f"{Colors.RED}❌ {text}{Colors.END}")

def print_warning(text: str):
    """Print warning message."""
    print(f"{Colors.YELLOW}⚠️  {text}{Colors.END}")

def print_info(text: str):
    """Print info message."""
    print(f"{Colors.BLUE}ℹ️  {text}{Colors.END}")

def run_command(cmd: str, description: str, capture_output: bool = True) -> Tuple[bool, str]:
    """Run a command and return success status and output."""
    print(f"{Colors.CYAN}🔄 {description}...{Colors.END}")
    try:
        if capture_output:
            result = subprocess.run(cmd, shell=True, check=True, capture_output=True, text=True)
            output = result.stdout.strip()
        else:
            result = subprocess.run(cmd, shell=True, check=True)
            output = ""
        
        print_success(f"{description} - Completed")
        return True, output
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr.strip() if hasattr(e, 'stderr') and e.stderr else str(e)
        print_error(f"{description} - Failed: {error_msg}")
        return False, error_msg

class SystemChecker:
    """Comprehensive system checker and fixer."""
    
    def __init__(self):
        self.issues = []
        self.fixes_applied = []
        
    def check_python_version(self) -> bool:
        """Check Python version compatibility."""
        version = sys.version_info
        print_info(f"Python version: {version.major}.{version.minor}.{version.micro}")
        
        if version.major < 3 or (version.major == 3 and version.minor < 11):
            self.issues.append("Python version too old (requires 3.11+)")
            print_error("Python 3.11+ required")
            return False
        
        print_success("Python version compatible")
        return True
    
    def check_project_structure(self) -> bool:
        """Check if we're in the correct project directory."""
        required_files = [
            "src/run_service.py",
            "src/streamlit_app.py", 
            "pyproject.toml",
            "src/core/settings.py"
        ]
        
        missing_files = []
        for file_path in required_files:
            if not Path(file_path).exists():
                missing_files.append(file_path)
        
        if missing_files:
            self.issues.append(f"Missing project files: {', '.join(missing_files)}")
            print_error("Not in correct project directory or files missing")
            return False
        
        print_success("Project structure valid")
        return True
    
    def create_optimal_env_file(self) -> bool:
        """Create an optimized .env file with default model configuration."""
        env_content = """# AI Agent Service Toolkit - Optimized Configuration
# Generated by FINAL_FIX.py

# =============================================================================
# DEFAULT MODEL CONFIGURATION (RECOMMENDED FOR CODING/DEVELOPMENT)
# =============================================================================

# Use fake model for immediate testing and development
USE_FAKE_MODEL=true

# Default model (will be overridden by USE_FAKE_MODEL=true)
DEFAULT_MODEL=fake

# =============================================================================
# PRODUCTION API KEYS (Add when ready for production)
# =============================================================================

# OpenAI (Recommended for production)
# OPENAI_API_KEY=your_openai_api_key_here

# Anthropic Claude (Alternative)
# ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Google Gemini (Alternative)
# GOOGLE_API_KEY=your_google_api_key_here

# Groq (Fast inference)
# GROQ_API_KEY=your_groq_api_key_here

# =============================================================================
# SERVER CONFIGURATION
# =============================================================================

# Server settings
HOST=0.0.0.0
PORT=8080

# Database (SQLite for development)
DATABASE_TYPE=sqlite
SQLITE_DB_PATH=checkpoints.db

# =============================================================================
# OPTIONAL: MONITORING & TRACING
# =============================================================================

# LangSmith tracing (optional)
# LANGCHAIN_TRACING_V2=true
# LANGCHAIN_API_KEY=your_langsmith_api_key_here
# LANGCHAIN_PROJECT=agent-service-toolkit

# Langfuse tracing (alternative)
# LANGFUSE_TRACING=true
# LANGFUSE_PUBLIC_KEY=your_langfuse_public_key_here
# LANGFUSE_SECRET_KEY=your_langfuse_secret_key_here

# =============================================================================
# DEVELOPMENT SETTINGS
# =============================================================================

# Enable development mode for auto-reload
MODE=dev

# Authentication (leave empty for development)
# AUTH_SECRET=your_secret_here

# Weather API (optional)
# OPENWEATHERMAP_API_KEY=your_weather_api_key_here
"""
        
        try:
            with open('.env', 'w') as f:
                f.write(env_content)
            self.fixes_applied.append("Created optimized .env file with fake model")
            print_success("Created optimized .env configuration")
            return True
        except Exception as e:
            print_error(f"Failed to create .env file: {e}")
            return False
    
    def check_and_fix_env(self) -> bool:
        """Check and fix environment configuration."""
        env_path = Path(".env")
        
        if not env_path.exists():
            print_warning(".env file missing")
            return self.create_optimal_env_file()
        
        # Check if .env has proper configuration
        with open(env_path, 'r') as f:
            content = f.read()
        
        # Check for fake model or API keys
        has_fake_model = 'USE_FAKE_MODEL=true' in content
        has_api_key = any(key in content for key in [
            'OPENAI_API_KEY=sk-',
            'ANTHROPIC_API_KEY=sk-',
            'GOOGLE_API_KEY=',
            'GROQ_API_KEY=gsk_'
        ])
        
        if not has_fake_model and not has_api_key:
            print_warning(".env file exists but no valid configuration found")
            # Backup existing .env
            shutil.copy('.env', '.env.backup')
            return self.create_optimal_env_file()
        
        print_success(".env file configured properly")
        return True
    
    def install_uv(self) -> bool:
        """Install UV package manager."""
        if shutil.which("uv"):
            print_success("UV package manager already installed")
            return True
        
        success, _ = run_command(
            f"{sys.executable} -m pip install uv",
            "Installing UV package manager"
        )
        
        if success:
            self.fixes_applied.append("Installed UV package manager")
        
        return success
    
    def install_dependencies(self) -> bool:
        """Install all required dependencies."""
        print_info("Installing dependencies (this may take a few minutes)...")
        
        # Method 1: Try UV sync
        if shutil.which("uv"):
            success, _ = run_command("uv sync --frozen", "Installing dependencies with UV")
            if success:
                self.fixes_applied.append("Installed dependencies with UV")
                return True
            
            print_warning("UV sync failed, trying UV install without lock...")
            success, _ = run_command("uv sync", "Installing dependencies with UV (no lock)")
            if success:
                self.fixes_applied.append("Installed dependencies with UV (regenerated lock)")
                return True
        
        # Method 2: Fallback to pip
        print_warning("Falling back to pip installation...")
        
        # Essential packages for the project
        essential_packages = [
            "langchain-core>=0.3.33",
            "langchain-anthropic>=0.3.0",
            "langchain-openai>=0.3.0",
            "langchain-community>=0.3.16",
            "langchain-google-genai>=2.0.11",
            "langchain-groq>=0.2.1",
            "langgraph>=0.3.5",
            "fastapi>=0.115.5",
            "streamlit>=1.40.1",
            "uvicorn>=0.32.1",
            "httpx>=0.27.2",
            "pydantic>=2.10.1",
            "python-dotenv>=1.0.1",
            "duckduckgo-search>=7.3.0",
            "numexpr>=2.10.1",
            "pandas>=2.2.3"
        ]
        
        for package in essential_packages:
            success, _ = run_command(
                f"{sys.executable} -m pip install '{package}'",
                f"Installing {package.split('>=')[0]}"
            )
            if not success:
                print_error(f"Failed to install {package}")
                return False
        
        self.fixes_applied.append("Installed dependencies with pip")
        return True
    
    def check_port_availability(self) -> bool:
        """Check if required ports are available."""
        ports = [8080, 8501]
        busy_ports = []
        
        for port in ports:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex(('localhost', port))
            sock.close()
            
            if result == 0:
                busy_ports.append(port)
        
        if busy_ports:
            print_warning(f"Ports in use: {', '.join(map(str, busy_ports))}")
            return self.free_ports(busy_ports)
        
        print_success("Required ports are available")
        return True
    
    def free_ports(self, ports: List[int]) -> bool:
        """Attempt to free busy ports."""
        try:
            import psutil
            
            killed_processes = []
            for port in ports:
                for proc in psutil.process_iter(['pid', 'name', 'connections']):
                    try:
                        connections = proc.info.get('connections') or []
                        for conn in connections:
                            if hasattr(conn, 'laddr') and conn.laddr.port == port:
                                proc.terminate()
                                killed_processes.append(f"PID {proc.info['pid']} on port {port}")
                                print_info(f"Terminated process {proc.info['pid']} using port {port}")
                    except (psutil.NoSuchProcess, psutil.AccessDenied, AttributeError):
                        continue
            
            if killed_processes:
                self.fixes_applied.append(f"Freed ports: {', '.join(killed_processes)}")
                time.sleep(2)  # Wait for processes to fully terminate
            
            return True
        except ImportError:
            print_warning("psutil not available, cannot automatically free ports")
            print_info("Please manually stop processes using ports 8080 and 8501")
            return False
    
    def test_imports(self) -> bool:
        """Test critical imports."""
        critical_imports = [
            ("langchain_core", "LangChain Core"),
            ("langchain_anthropic", "LangChain Anthropic"),
            ("langchain_openai", "LangChain OpenAI"),
            ("langgraph", "LangGraph"),
            ("fastapi", "FastAPI"),
            ("streamlit", "Streamlit"),
            ("pydantic", "Pydantic")
        ]
        
        failed_imports = []
        for module, name in critical_imports:
            try:
                __import__(module)
                print_success(f"{name} import successful")
            except ImportError as e:
                failed_imports.append((module, name, str(e)))
                print_error(f"{name} import failed: {e}")
        
        if failed_imports:
            self.issues.append(f"Import failures: {', '.join([name for _, name, _ in failed_imports])}")
            return False
        
        return True
    
    def test_core_functionality(self) -> bool:
        """Test core application functionality."""
        try:
            # Test settings import
            sys.path.insert(0, str(Path("src").absolute()))
            from core.settings import settings
            print_success("Settings module loaded")
            
            # Test model loading
            from core.llm import get_model
            from schema.models import FakeModelName
            
            model = get_model(FakeModelName.FAKE)
            print_success("Fake model loaded successfully")
            
            # Test agent loading
            from agents import get_agent
            agent = get_agent("chatbot")
            print_success("Agent system functional")
            
            return True
        except Exception as e:
            print_error(f"Core functionality test failed: {e}")
            self.issues.append(f"Core functionality error: {e}")
            return False
    
    def create_startup_scripts(self) -> bool:
        """Create convenient startup scripts."""
        
        # Windows batch script
        windows_script = """@echo off
echo 🚀 Starting AI Agent Service Toolkit...
echo.

REM Check if virtual environment exists
if not exist ".venv" (
    echo Creating virtual environment...
    python -m venv .venv
)

echo Activating virtual environment...
call .venv\\Scripts\\activate.bat

echo Starting FastAPI service...
start "FastAPI Service" cmd /k "python src\\run_service.py"

echo Waiting for service to start...
timeout /t 5 /nobreak > nul

echo Starting Streamlit app...
start "Streamlit App" cmd /k "streamlit run src\\streamlit_app.py"

echo.
echo ✅ Services are starting...
echo 🌐 FastAPI service: http://localhost:8080
echo 🎨 Streamlit app: http://localhost:8501
echo.
echo Press any key to exit...
pause
"""
        
        # Unix shell script
        unix_script = """#!/bin/bash
echo "🚀 Starting AI Agent Service Toolkit..."
echo

# Check if virtual environment exists
if [ ! -d ".venv" ]; then
    echo "Creating virtual environment..."
    python -m venv .venv
fi

echo "Activating virtual environment..."
source .venv/bin/activate

echo "Starting FastAPI service in background..."
python src/run_service.py &
SERVICE_PID=$!

echo "Waiting for service to start..."
sleep 5

echo "Starting Streamlit app..."
streamlit run src/streamlit_app.py &
APP_PID=$!

echo
echo "✅ Services are running:"
echo "🌐 FastAPI service: http://localhost:8080"
echo "🎨 Streamlit app: http://localhost:8501"
echo
echo "Press Ctrl+C to stop all services"

# Wait for interrupt
trap "kill $SERVICE_PID $APP_PID 2>/dev/null; exit" INT
wait
"""
        
        try:
            # Write Windows script
            with open("start_services.bat", "w") as f:
                f.write(windows_script)
            
            # Write Unix script
            with open("start_services.sh", "w") as f:
                f.write(unix_script)
            
            # Make Unix script executable
            try:
                os.chmod("start_services.sh", 0o755)
            except:
                pass
            
            self.fixes_applied.append("Created startup scripts")
            print_success("Created startup scripts (start_services.bat/sh)")
            return True
        except Exception as e:
            print_error(f"Failed to create startup scripts: {e}")
            return False

def main():
    """Main execution function."""
    print_header("AI AGENT SERVICE TOOLKIT - FINAL FIX")
    print(f"{Colors.BOLD}🎯 This script will completely fix and optimize your setup{Colors.END}")
    
    checker = SystemChecker()
    
    # Step 1: Basic system checks
    print_header("STEP 1: SYSTEM VALIDATION")
    
    if not checker.check_python_version():
        print_error("Python version incompatible. Please install Python 3.11+")
        return False
    
    if not checker.check_project_structure():
        print_error("Project structure invalid. Please run from project root.")
        return False
    
    # Step 2: Environment setup
    print_header("STEP 2: ENVIRONMENT CONFIGURATION")
    
    if not checker.check_and_fix_env():
        print_error("Failed to configure environment")
        return False
    
    # Step 3: Package management
    print_header("STEP 3: DEPENDENCY INSTALLATION")
    
    if not checker.install_uv():
        print_warning("UV installation failed, will use pip")
    
    if not checker.install_dependencies():
        print_error("Failed to install dependencies")
        return False
    
    # Step 4: Port management
    print_header("STEP 4: PORT CONFIGURATION")
    
    if not checker.check_port_availability():
        print_warning("Port conflicts detected but handled")
    
    # Step 5: Functionality testing
    print_header("STEP 5: FUNCTIONALITY TESTING")
    
    if not checker.test_imports():
        print_error("Critical import failures detected")
        return False
    
    if not checker.test_core_functionality():
        print_error("Core functionality test failed")
        return False
    
    # Step 6: Convenience setup
    print_header("STEP 6: CONVENIENCE SETUP")
    
    checker.create_startup_scripts()
    
    # Final summary
    print_header("SETUP COMPLETE!")
    
    if checker.fixes_applied:
        print(f"{Colors.GREEN}🔧 Fixes Applied:{Colors.END}")
        for fix in checker.fixes_applied:
            print(f"  ✅ {fix}")
    
    if checker.issues:
        print(f"\n{Colors.YELLOW}⚠️  Remaining Issues:{Colors.END}")
        for issue in checker.issues:
            print(f"  ❌ {issue}")
    
    # Instructions
    print(f"\n{Colors.BOLD}{Colors.GREEN}🚀 READY TO RUN!{Colors.END}")
    print(f"\n{Colors.CYAN}Quick Start Options:{Colors.END}")
    print(f"  {Colors.WHITE}Option 1 - Use startup scripts:{Colors.END}")
    print(f"    Windows: {Colors.YELLOW}start_services.bat{Colors.END}")
    print(f"    macOS/Linux: {Colors.YELLOW}./start_services.sh{Colors.END}")
    
    print(f"\n  {Colors.WHITE}Option 2 - Manual start:{Colors.END}")
    print(f"    Terminal 1: {Colors.YELLOW}python src/run_service.py{Colors.END}")
    print(f"    Terminal 2: {Colors.YELLOW}streamlit run src/streamlit_app.py{Colors.END}")
    
    print(f"\n{Colors.CYAN}Access URLs:{Colors.END}")
    print(f"  🌐 FastAPI Service: {Colors.YELLOW}http://localhost:8080{Colors.END}")
    print(f"  🎨 Streamlit App: {Colors.YELLOW}http://localhost:8501{Colors.END}")
    print(f"  📚 API Docs: {Colors.YELLOW}http://localhost:8080/redoc{Colors.END}")
    
    print(f"\n{Colors.CYAN}Default Configuration:{Colors.END}")
    print(f"  🤖 Model: {Colors.YELLOW}Fake Model (for testing){Colors.END}")
    print(f"  🗄️  Database: {Colors.YELLOW}SQLite (checkpoints.db){Colors.END}")
    print(f"  🔐 Auth: {Colors.YELLOW}Disabled (development mode){Colors.END}")
    
    print(f"\n{Colors.BLUE}💡 Next Steps:{Colors.END}")
    print(f"  1. Start the services using one of the options above")
    print(f"  2. Open {Colors.YELLOW}http://localhost:8501{Colors.END} in your browser")
    print(f"  3. Try asking: {Colors.YELLOW}'Hello, how are you?'{Colors.END}")
    print(f"  4. Add real API keys to .env when ready for production")
    
    return len(checker.issues) == 0

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}⚠️  Setup interrupted by user{Colors.END}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.RED}❌ Unexpected error: {e}{Colors.END}")
        sys.exit(1)